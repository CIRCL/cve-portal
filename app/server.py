#!/usr/bin/env python2
# -*-coding:UTF-8 -*

import ConfigParser
import gnupg
from functools import wraps
from flask.ext.script import Manager
from flask import Flask, render_template, request, flash, redirect, url_for, abort, jsonify
from flask.ext.bootstrap import Bootstrap
from flask.ext.login import LoginManager, login_user, logout_user, login_required, current_user
from flask.ext.mail import Mail, Message
from flask.ext.pymongo import PyMongo
from sqlalchemy import desc
import models
import form_class
import redis
import cve_redis
import json
import cgi
import syslog
from bson import json_util

#Login_manager (session)
login_manager = LoginManager()
login_manager.session_protection = 'strong'

# Parsing Conf File #
configfile = 'config/config.cfg'
cfg = ConfigParser.ConfigParser()
cfg.read(configfile)

########################################################################
####################### APP INIT & CONFIG ##############################
########################################################################
app = Flask(__name__)

manager = Manager(app)
mail = Mail(app)
login_manager.init_app(app)
bootstrap = Bootstrap(app)
app.config['SECRET_KEY'] = cfg.get("Secret", "wtf_secret_key")

# app.config['SERVER_NAME'] = "www.circl.lu:443"
# app.config['APPLICATION_ROOT'] = '/cve-portal'
# app.config['WTF_CSRF_ENABLED'] = True

# SMTP email config #
app.config['MAIL_SERVER'] = cfg.get('SMTP', 'server')
app.config['MAIL_PORT'] = cfg.get('SMTP', 'port')
app.config['MAIL_USE_TLS'] = cfg.get('SMTP', 'tls')
app.config['DEFAULT_MAIL_SENDER'] = cfg.get('SMTP', 'sender')

# Super Admin #
app.config['PORTAL_ADMIN'] = cfg.get('ADMIN', 'mail')

#  REDIS CONNECTION  #
r = redis.StrictRedis(host=cfg.get('REDIS', 'host'),
                      port=cfg.get('REDIS', 'port'),
                      db=cfg.get('REDIS', 'db'))

#  MONGO  #
app.config['MONGO_DBNAME'] = cfg.get('MONGO', 'dbname')
m = PyMongo(app)

# GPG #
gpg = gnupg.GPG(homedir=cfg.get('GPG', 'directory'))

# SYSLOG #
syslog.openlog(cfg.get('SYSLOG', 'ident'), logoption=syslog.LOG_PID, facility=syslog.LOG_USER)


def send_email(to, subject, template, **kwargs):
    msg = Message(subject, recipients=[to], sender=cfg.get('SMTP', 'sender'))
    msg.body = render_template(template + '.txt', **kwargs)
    msg.html = render_template(template + '.html', **kwargs)
    return mail.send(msg)


def permission_required(permission):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.can(permission):
                abort(403)
            return f(*args, **kwargs)
        return decorated_function
    return decorator


def admin_required(f):
    return permission_required(models.Permission.ADMINISTER)(f)

########################################################################
############################# ROUTES ###################################
########################################################################

req_endpoint = ['unconfirmed', 'logout', 'confirm']


@app.before_request
def before_request():
    if current_user.is_authenticated():
        current_user.ping()
        if not current_user.confirmed and request.endpoint not in req_endpoint:
            return redirect(url_for('unconfirmed'))


@app.teardown_appcontext
def shutdown_session(exception=None):
    models.db.session.remove()


@login_manager.user_loader
def load_user(user_id):
    return models.User.query.get(int(user_id))


@app.route('/', methods=['GET', 'POST'])
def index():
    return render_template("index.html")


@app.route('/register', methods=['GET', 'POST'])
def register():
    form = form_class.RegistrationForm()
    if form.validate_on_submit():
        ki = gpg.import_keys(form.pgp.data)
        if ki.fingerprints == []:
            fingerp = "--- NO VALID PGP ---"
        else:
            fingerp = ki.fingerprints[0]
        user = models.User(email=form.email.data,
                           name=form.name.data,
                           affiliation=form.affiliation.data,
                           pgp=form.pgp.data,
                           password=form.password.data,
                           fingerprint=fingerp)
        models.db.session.add(user)
        models.db.session.commit()
        syslog.syslog(syslog.LOG_NOTICE, "New user registered: " + form.email.data)
        token = user.generate_confirmation_token()
        send_email(user.email,
                   'CVE-PORTAL -- Account Confirmation',
                   '/emails/confirm',
                   user=user,
                   token=token)
        flash('A confirmation email has been sent to you by email.', 'info')
        return redirect('/login')
    else:
        if form.email.data is not None:
            syslog.syslog(syslog.LOG_ERR,
                          "Registering Failed: Email: " + form.email.data +
                          " Name: " + form.name.data +
                          " Affiliation: " + form.affiliation.data)

    return render_template("auth/register.html", form=form)


@app.route('/login', methods=['GET', 'POST'])
def login():
    form = form_class.LoginForm()
    if form.validate_on_submit():
        user = models.User.query.filter_by(email=form.email.data).first()
        if user is not None and user.verify_password(form.password.data):
            login_user(user, form.remember_me.data)
            flash('You are now logged', 'success')
            syslog.syslog(syslog.LOG_INFO, "User Logged: " + form.email.data)
            return redirect(request.args.get("next") or url_for("index"))
        flash('Wrong email/password', 'danger')
        syslog.syslog(syslog.LOG_ERR, "User Login Failed: " + form.email.data)
    return render_template('auth/login.html', form=form)


@app.route('/logout')
@login_required
def logout():
    logout_user()
    flash('You have been logged out', 'info')
    return redirect('/')


@app.route('/confirm')
@login_required
def resend_confirmation():
    token = current_user.generate_confirmation_token()
    send_email(current_user.email,
               'CVE-PORTAL -- Account Confirmation',
               '/emails/confirm',
               user=current_user,
               token=token)
    syslog.syslog(syslog.LOG_WARNING, "User Resend a Confirmation Email to: " + current_user.email)
    flash('A new confirmation email has been sent to you by email.', 'info')
    return redirect(url_for('index'))


@app.route('/confirm/<token>')
@login_required
def confirm(token):
    if current_user.confirmed:
        return redirect(url_for('index'))
    if current_user.confirm(token):
        syslog.syslog(syslog.LOG_INFO, "User Confirmed Account: " + current_user.email)
        flash('You have confirmed your account. Thanks !', 'success')
    else:
        syslog.syslog(syslog.LOG_ERR, "User Confirmed Failed invalid/expired link: " + current_user.email)
        flash('The confirmation link is invalid or has expired.', 'warning')
    return redirect(url_for('index'))


@app.route('/unconfirmed')
def unconfirmed():
    if current_user.is_anonymous() or current_user.confirmed:
        return redirect(url_for('index'))
    return render_template('auth/unconfirmed.html')


@app.route('/change_password', methods=['GET', 'POST'])
@login_required
def change_password():
    form = form_class.ChangePasswordForm()
    if form.validate_on_submit():
        if current_user.verify_password(form.old_password.data):
            current_user.password = form.password.data
            models.db.session.add(current_user)
            models.db.session.commit()
            flash('Your password has been updated.', 'info')
            syslog.syslog(syslog.LOG_INFO, "User changed his password: " + current_user.email)
            return redirect(url_for('index'))
        else:
            flash('Invalid password.', 'danger')
    return render_template("auth/change_password.html", form=form)


@app.route('/reset_pwd', methods=['GET', 'POST'])
def password_reset_request():
    if not current_user.is_anonymous():
        return redirect(url_for('index'))
    form = form_class.PasswordResetRequestForm()
    if form.validate_on_submit():
        user = models.User.query.filter_by(email=form.email.data).first()
        if user:
            token = user.generate_reset_token()
            send_email(user.email,
                       'CVE-PORTAL -- Reset Password Request',
                       '/emails/password_reset',
                       user=user,
                       token=token,
                       next=request.args.get('next'))
            syslog.syslog(syslog.LOG_WARNING, "User password reset request is asked: " + current_user.email)
            flash('An email with instructions to reset your password has been sent to you.', 'info')
            return redirect(url_for('login'))
    return render_template('auth/reset_password.html', form=form)


@app.route('/change_email', methods=['GET', 'POST'])
@login_required
def change_email_request():
    form = form_class.ChangeEmailForm()
    if form.validate_on_submit():
        if current_user.verify_password(form.password.data):
            new_email = form.email.data
            token = current_user.generate_email_change_token(new_email)
            send_email(new_email,
                       'CVE-PORTAL -- Confirm your email address',
                       '/emails/change_email',
                       user=current_user,
                       token=token)
            syslog.syslog(syslog.LOG_WARNING, "User as requested an email change: Old:" + current_user.email + " New: " + form.email.data)
            flash('An email with instructions to confirm your new email address has been sent to you.', 'info')
            return redirect(url_for('index'))
        else:
            flash('Invalid email or password.', 'danger')
    return render_template("auth/change_email.html", form=form)


@app.route('/change_pgp', methods=['GET', 'POST'])
@login_required
def change_pgp():
    form = form_class.ChangePGPForm()
    if form.validate_on_submit():
        if current_user.verify_password(form.password.data):
            ki = gpg.import_keys(form.pgp.data)
            if ki.fingerprints == []:
                fingerp = "--- NO VALID PGP ---"
            else:
                fingerp = ki.fingerprints[0]
            current_user.pgp = form.pgp.data
            current_user.fingerprint = fingerp
            models.db.session.add(current_user)
            models.db.session.commit()
            flash('Your PGP key has been updated.', 'info')
            syslog.syslog(syslog.LOG_INFO, "User Changed his PGP: " + current_user.email)
            return redirect(url_for('index'))
        else:
            flash('Invalid password.', 'danger')
    return render_template("auth/change_pgp.html", form=form)


@app.route('/change_email/<token>')
@login_required
def change_email(token):
    if current_user.change_email(token):
        syslog.syslog(syslog.LOG_INFO, "User e-mail updated: " + current_user.email)
        flash('Your email address has been updated.', 'success')
    else:
        syslog.syslog(syslog.LOG_ERR, "Email change: Invalid link request: " + current_user.email)
        flash('Invalid request.', 'warning')
    return redirect(url_for('index'))


@app.route('/reset/<token>', methods=['GET', 'POST'])
def password_reset(token):
    if not current_user.is_anonymous():
        return redirect(url_for('index'))
    form = form_class.PasswordResetForm()
    if form.validate_on_submit():
        user = models.User.query.filter_by(email=form.email.data).first()
        if user is None:
            return redirect(url_for('index'))
        if user.reset_password(token, form.password.data):
            flash('Your password has been updated.', 'success')
            return redirect(url_for('login'))
        else:
            return redirect(url_for('index'))
    return render_template('auth/reset_password.html', form=form)


@app.route('/admin', methods=['GET', 'POST'])
@login_required
@admin_required
def admin_home():
    newform = form_class.RegistrationForm()
    updateform = form_class.UpdateUserForm()
    deleteform = form_class.DeleteUserForm()

    if deleteform.validate_on_submit():
        if (deleteform.id.data) != '1':
            user = models.User.query.filter_by(id=deleteform.id.data).first()
            models.db.session.delete(user)
            models.db.session.commit()
            flash('User successfully deleted', 'success')
            syslog.syslog(syslog.LOG_CRIT, "Admin: " + current_user.email + " deleted User: " + user.email)
        else:
            flash("Sorry but you just can't delete this admin", 'danger')
            syslog.syslog(syslog.LOG_ALERT, "User wanted to delete admin" + current_user.email)
        return redirect(url_for('admin_home'))

    elif newform.validate_on_submit():
        ki = gpg.import_keys(newform.pgp.data)
        if ki.fingerprints == []:
            fingerp = "--- NO VALID PGP ---"
        else:
            fingerp = ki.fingerprints[0]
        user = models.User(email=newform.email.data,
                           name=newform.name.data,
                           affiliation=newform.affiliation.data,
                           pgp=newform.pgp.data,
                           password=newform.password.data,
                           fingerprint=fingerp)

        models.db.session.add(user)
        models.db.session.commit()
        syslog.syslog(syslog.LOG_WARNING, "Admin: " + current_user.email + " created User: " + user.email)
        flash('User successfully created.', 'success')
        return redirect(url_for('admin_home'))

    elif updateform.validate_on_submit():
        ki = gpg.import_keys(updateform.pgp.data)
        if ki.fingerprints == []:
            fingerp = "--- NO VALID PGP ---"
        else:
            fingerp = ki.fingerprints[0]
        user = models.User.query.filter_by(id=updateform.id.data).first()
        user.name = updateform.name.data
        user.affiliation = updateform.affiliation.data
        user.fingerprint = fingerp
        user.pgp = updateform.pgp.data

        if updateform.id.data != '1':
            listemail = []
            for user in models.User.query.all():
                listemail.append(user.email)
            if updateform.email.data not in listemail or updateform.email.data == models.User.query.filter_by(id=updateform.id.data).first().email:
                user.email = updateform.email.data
                user.confirmed = updateform.confirmed.data
                user.role = models.Role.query.get(updateform.role.data)
            else:
                syslog.syslog(syslog.LOG_ERR, "Admin: " + current_user.email + " Tried to assign existing email to user: " + user.email)
                flash('Email already existing', 'warning')
                return redirect(url_for('admin_home'))
        else:
            user.role = models.Role.query.get('1')
            user.email = cfg.get('ADMIN', 'mail')
            user.confirmed = True
            syslog.syslog(syslog.LOG_ALERT, "Admin: " + current_user.email + " Tried to remove right of Admin: " + user.email)

        models.db.session.add(user)
        models.db.session.commit()
        syslog.syslog(syslog.LOG_WARNING, "Admin: " + current_user.email + " updated User: " + user.email)
        flash('User successfully updated', 'success')
        return redirect(url_for('admin_home'))

    return render_template("admin_home.html",
                           newform=newform,
                           updateform=updateform,
                           deleteform=deleteform)


@app.route('/userjson', methods=['GET', 'POST'])
@login_required
@admin_required
def userjson():
    jusers = []
    dusers = {}
    dic = {}

    limit = request.args.get('limit')
    offset = request.args.get('offset')
    sort = request.args.get('sort')
    order = request.args.get('order')

    if order == 'desc':
        user_list = models.User.query.order_by(desc(sort)).limit(limit).offset(offset).all()
    else:
        user_list = models.User.query.order_by(sort).limit(limit).offset(offset).all()

    num = models.User.query.count()

    for user in user_list:
        dusers = {'id': user.id,
                  'name': user.name,
                  'email': user.email,
                  'affiliation': user.affiliation,
                  'pgp': user.pgp,
                  'fingerprint': user.fingerprint,
                  'confirmed': user.confirmed,
                  'role_id2': user.role_id,
                  'role_id': (models.Role.query.filter_by(id=user.role_id).first()).name
                  }
        jusers.append(dusers)

    dic['total'] = num
    dic['rows'] = jusers
    return jsonify(dic)


@app.route('/user', methods=['GET', 'POST'])
@login_required
def user():
    return render_template('user.html')


@app.route('/notiftab', methods=['GET', 'POST'])
@login_required
def notiftab():
    jnotif = []
    dnotif = {}
    dic = {}

    limit = request.args.get('limit')
    offset = request.args.get('offset')
    sort = request.args.get('sort')
    order = request.args.get('order')

    if order == 'desc':
        notif_list = models.Notification.query.filter_by(user_id=current_user.id).order_by(desc(sort)).limit(limit).offset(offset).all()
    else:
        notif_list = models.Notification.query.filter_by(user_id=current_user.id).order_by(sort).limit(limit).offset(offset).all()

    num = models.Notification.query.filter_by(user_id=current_user.id).count()

    for notif in notif_list:
        dnotif = {'id': notif.id,
                  'vendor': notif.vendor,
                  'product': notif.product,
                  'version': notif.version
                  }
        jnotif.append(dnotif)

    dic['total'] = num
    dic['rows'] = jnotif
    return jsonify(dic)


@app.route('/notifjson', methods=['GET', 'POST'])
@login_required
def notifjson():
    vendors = []
    products = []
    versions = []
    if request.json is not None:
        if request.json['queryvendor'] != "":  # SEARCH BY VENDORS
            vendors = cve_redis.search_vendor(r, request.json['queryvendor'])
            products = cve_redis.search_vendor_product(r, request.json['queryproduct'], request.json['queryvendor'])
            versions = cve_redis.product_versions(r, request.json['queryproduct'])
        elif request.json['queryproduct'] != "":  # SEARCH BY PRODUCTS
            products = cve_redis.search_product(r, request.json['queryproduct'])
            vendors = cve_redis.get_vendor(r, request.json['queryproduct'])
            versions = cve_redis.product_versions(r, request.json['queryproduct'])

    return jsonify({"vendors": vendors,
                    "products": products,
                    "versions": versions})


@app.route('/addnotif', methods=['GET', 'POST'])
@login_required
def addnotif():
    if request.json['allversion'] is True and request.json['allproduct'] is False:
        notification = models.Notification(user_id=current_user.id,
                                           vendor=request.json['queryvendor'],
                                           product=request.json['queryproduct'],
                                           version='')

    elif request.json['allproduct'] is True:
        notification = models.Notification(user_id=current_user.id,
                                           vendor=request.json['queryvendor'],
                                           product='',
                                           version='')
    else:
        notification = models.Notification(user_id=current_user.id,
                                           vendor=request.json['queryvendor'],
                                           product=request.json['queryproduct'],
                                           version=request.json['queryversion'])

    #  Checking Integrity Before Insert  #
    if models.Notification.query.filter_by(user_id=notification.user_id,
                                           vendor=notification.vendor,
                                           product=notification.product,
                                           version=notification.version).first() is None:
        models.db.session.add(notification)
        models.db.session.commit()
        flash('Notification Successfully Created.', 'success')
        syslog.syslog(syslog.LOG_DEBUG, "New notification created by: " + current_user.email)
        return redirect(url_for("notiftab"))

    else:
        flash('Notification Already existing.', 'warning')
        syslog.syslog(syslog.LOG_ERR, "Notification Already existing: " + current_user.email)
        return redirect(url_for("notiftab"))


@app.route('/delnotif', methods=['GET', 'POST'])
@login_required
def delnotif():
    row = models.Notification.query.filter_by(id=request.json).first()
    models.db.session.delete(row)
    models.db.session.commit()
    flash('Notification removed ', 'info')
    syslog.syslog(syslog.LOG_DEBUG, "Notification deleted: " + current_user.email)
    return redirect(url_for("notiftab"))


@app.route('/checknotif', methods=['GET', 'POST'])
@login_required
def checknotif():
    if request.json["product"] == '':
        req = ':'+request.json['vendor']+':'
    else:
        req = request.json["vendor"] + ':' + request.json["product"] + ':' + request.json["version"]

    tab = []
    keytab = ['summary']
    print req
    for cves in m.db.cves.find({'vulnerable_configuration': {'$regex': req}}):
        dic = {}
        for key, value in cves.items():
            if key in keytab:
                dic[key] = cgi.escape(value, quote=True)
            else:
                dic[key] = value
        tab.append(dic)
    return json.dumps(tab, sort_keys=True, default=json_util.default)


@app.route('/searchnotif', methods=['GET', 'POST'])
@login_required
def searchnotif():
    print "REQUEST JSON", request.json['searchquery']
    search = models.FullTextNotification(user_id=current_user.id,
                                         fullnotif=request.json['searchquery'])
    models.db.session.add(search)
    models.db.session.commit()
    return redirect(url_for("notiftab"))
    #cve_whoosh.whooshquerying(request.json['searchquery'])


@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404


@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500


@app.errorhandler(401)
def unauthorized(e):
    return render_template('401.html'), 401


@app.errorhandler(403)
def forbidden(e):
    return render_template('403.html'), 403


if __name__ == "__main__":
    manager.run()
